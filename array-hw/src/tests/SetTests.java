package tests;

import adts.ISet;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import structure.ArraySet;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests an implementation of the ISet interface.
 *
 * DO NOT EDIT THIS FILE!
 *
 * @author Josh Archer
 * @version 1.0
 */
public class SetTests
{
    private ISet set;

    //test arrays
    private Integer[] noDupsArray = {5, 8, 7, 4, 3, 6};
    private Integer[] dupsArray = {3, 5, 5, 6, 3, 6};
    private int[] missing = {1, 2, 9, 10};

    /*
        This method should create and return a new set
        for the methods below.
     */
    private ISet createSet()
    {
        //instantiate your class here!
        return new ArraySet();
    }

    /**
     * Creates a new set before each test.
     */
    @BeforeEach
    public void setup()
    {
        set = createSet();
    }

    /**
     * Tests whether elements can be added to
     * the set successfully.
     */
    @Test
    public void addingElementsTest()
    {
        addNoDupsElements();

        for (int i = 0; i < noDupsArray.length; i++)
        {
            assertTrue(set.contains(noDupsArray[i]), "Elements added to set not discoverable with contains()");
        }
    }

    /**
     * Tests whether duplicate elements are rejected after
     * calling add().
     */
    @Test
    public void duplicateElementsTest()
    {
        int dupsCount = 0;
        for (int i = 0; i < dupsArray.length; i++)
        {
            try
            {
                set.add(dupsArray[i]);
            }
            catch (IllegalArgumentException ex)
            {
                dupsCount++;
            }
        }

        //three dups should be found
        assertEquals(3, dupsCount, "All three duplicate elements were not rejected");

        //there are three unique elements in the input array
        assertEquals(3, set.size(), "There should be three unique elements in the set after rejected duplicates");
    }

    /**
     * Verifies that the element count in the set is correct
     * after calling addAll().
     */
    @Test
    public void addAllTest()
    {
        set.addAll(noDupsArray);
        assertEquals(noDupsArray.length, set.size(),
                "There should be " + noDupsArray.length + " unique elements in the set after calling addAll()");
    }

    /**
     * Verifies that duplicates are caught between
     * input parameters and elements already in the set.
     */
    @Test
    public void addAllDuplicateElementsTest()
    {
        addNoDupsElements();
        assertThrows(IllegalArgumentException.class, () -> set.addAll(noDupsArray));
    }

    /**
     * Verifies that duplicate parameters result in
     * an exception.
     */
    @Test
    public void addAllDuplicateParametersTest()
    {
        assertThrows(IllegalArgumentException.class, () -> set.addAll(dupsArray));
    }

    /**
     * Verifies that the set reports the size of the structure
     * correctly.
     */
    @Test
    public void sizeTest()
    {
        addNoDupsElements();

        //list should be empty to start with
        assertEquals(set.size(), noDupsArray.length,
                "List should have size " + noDupsArray.length + "after calls to add()");
        assertFalse(set.isEmpty(), "List should not be empty after calling add()");
    }

    /**
     * Verifies that the set reports the size of the structure
     * correctly.
     */
    @Test
    public void sizeEmptyTest()
    {
        //list should be empty to start with
        assertEquals(0, set.size(), "List should have size 0 after no calls to add()");
        assertTrue(set.isEmpty(), "List should be empty after no calls to add()");
    }

    /**
     * Verifies that the capacity does not change unless exceeded.
     */
    @Test
    public void capacityTest()
    {
        addNoDupsElements();

        //capacity should be the same after a few (< 10) elements are added
        assertEquals(10, set.capacity(), "Capacity should be 10 unless 11 or more elements have been added");
    }

    /**
     * Verifies that the capacity of an empty set defaults to 10.
     */
    @Test
    public void capacityEmptyTest()
    {
        assertEquals(10, set.capacity(), "Capacity should default to 10 for a new set");
    }

    /**
     * Verifies that the internal capacity of the set is doubling as necessary.
     */
    @Test
    public void resizeCapacityTest()
    {
        int[] boundaries = {10, 20, 40, 80, 160, 320, 640, 1280};
        int boundaryIndex = 0;
        for (int i = 1; i <= boundaries[boundaries.length - 2] + 1; i++)
        {
            set.add(i);

            if (i == boundaries[boundaryIndex] + 1)
            {
                boundaryIndex++;
            }

            int expectedCap = boundaries[boundaryIndex];
            assertEquals(expectedCap, set.capacity(),
                "Capacity should be " + expectedCap + " unless " + (expectedCap + 1) +
                " or more elements have been added");
        }
    }

    /**
     * Verifies that elements can be found in the set
     * with contains().
     */
    @Test
    public void containsExistsTest()
    {
        addNoDupsElements();

        //make sure elements are discoverable
        for (int i = 0; i < noDupsArray.length; i++)
        {
            assertTrue(set.contains(noDupsArray[i]), "Added element not discoverable by contains()");
        }
    }

    /**
     * Verifies that elements not in the set cannot be discovered
     * with contains().
     */
    @Test
    public void containsMissingTest()
    {
        addNoDupsElements();

        //make sure elements are discoverable
        for (int i = 0; i < missing.length; i++)
        {
            assertFalse(set.contains(missing[i]), "Missing element is discoverable by contains()");
        }
    }

    /**
     * Verifies that contains() does not return true
     * when the set is empty.
     */
    @Test
    public void containsOnEmptyListTest()
    {
        //contains should always return false on empty set
        assertFalse(set.contains(3), "Missing element is discoverable by contains()");

        //add an element and confirm contains() can discover it
        set.add(3);
        assertTrue(set.contains(3), "Element added to set is not discoverable by contains()");
    }

    /**
     * Verifies that various elements added to a set can each be found and
     * removed.
     * @param toRemove the element to search for
     */
    @ParameterizedTest
    @ValueSource(ints = {5, 8, 7, 4, 3, 6})
    public void removeIndividual(int toRemove)
    {
        addNoDupsElements();
        assertEquals(noDupsArray.length, set.size(), "List size should be " +
                noDupsArray.length + " before removing all elements");

        set.remove(toRemove);
        assertEquals(noDupsArray.length - 1, set.size(),
            "List size should be one smaller after removing all elements");
        assertFalse(set.contains(toRemove), "Element can be found after being removed");
    }

    /**
     * Removes several elements from the set and verifies that
     * they are no longer in the set.
     */
    public void removeExistsTest()
    {
        addNoDupsElements();

        //get a random remove order
        Integer[] shuffled = shuffleNewArray(noDupsArray);

        //remove in random order
        for (int i = 0; i < shuffled.length; i++)
        {
            set.remove(shuffled[i]);
        }

        assertEquals(0, set.size(), "List size should be 0 after removing all elements");
        assertTrue(set.isEmpty(), "List should be empty after removing all elements");
    }

    private Integer[] shuffleNewArray(Integer[] array)
    {
        Random random = new Random();
        Integer[] copied = new Integer[array.length];
        System.arraycopy(array, 0, copied, 0, array.length);

        for (int i = 0; i < copied.length; i++)
        {
            swap(i, random.nextInt(copied.length), copied);
        }

        return copied;
    }

    private void swap(int first, int second, Integer[] array)
    {
        int temp = array[first];
        array[first] = array[second];
        array[second] = temp;
    }

    /**
     * Verifies that various missing elements cannot be removed from the set.
     */
    @ParameterizedTest
    @ValueSource(ints = {2, 9, -2, 0, 11})
    public void removeMissingTest(int toFind)
    {
        addNoDupsElements();

        assertThrows(NoSuchElementException.class, () -> set.remove(toFind),
                "No exception is thrown when removing a missing element");
    }

    /**
     * Verifies that the correct exception is thrown when removing from an empty set.
     */
    @Test
    public void removeOnEmptySetTest()
    {
        //no elements are present, this should give an exception
        assertThrows(NoSuchElementException.class, () -> set.remove(2),
                "Exception should be thrown on an empty set");
    }

    /**
     * Verifies that clear() works correctly on an empty
     * set.
     */
    @Test
    public void clearEmptyTest()
    {
        //make sure no errors are encountered
        set.clear();

        assertEquals(0, set.size(), "Set size should be 0 after calling clear()");
        assertTrue(set.isEmpty(), "Set should be empty after calling clear");
    }

    /**
     * Verifies that clear() works correctly on a non-empty
     * set.
     */
    @Test
    public void clearNotEmptyTest()
    {
        addNoDupsElements();

        //make sure no errors are encountered
        set.clear();

        assertEquals(0, set.size(), "Set size should be 0 after calling clear()");
        assertTrue(set.isEmpty(), "Set should be empty after calling clear");
    }

    /**
     * Tests that a large number of elements can be added to the set and it
     * behaves predictably. This test is repeated 10 times with different
     * numbers of elements added to the set, as well as different amount
     * of duplicates.
     */
    @RepeatedTest(10)
    public void largeSetTest()
    {
        Random random = new Random();
        int randomSetSize = Math.max(5, random.nextInt(1000));

        //the higher this number, the more duplicates will be created
        int duplicateChance = random.nextInt(5) + 1;
        int successfulAdds = 0, unsuccessfulAdds = 0;

        //add enough elements for force a resize
        ArrayList<Integer> added = new ArrayList<>();
        for (int i = 1; i <= randomSetSize; i++)
        {
            int element = randomSetSize / duplicateChance;
            added.add(element);

            try
            {
                set.add(element);
                successfulAdds++;
            }
            catch (IllegalArgumentException ex)
            {
                unsuccessfulAdds++;
            }
        }

        //make sure elements are discoverable
        for (int i = 0; i < added.size(); i++)
        {
            assertTrue(set.contains(added.get(i)), "Element is not discoverable by contains()");
        }

        //number of elements should not be zero
        assertEquals(successfulAdds, set.size(),
                "Set size should be " + successfulAdds + " after calling add 1000 times");
        assertFalse(set.isEmpty(), "Set should not be empty after calling add()");
    }

    /**
     * Verifies that add() works correctly after adding
     * elements, removing all elements, then inserting
     * a new element.
     */
    @Test
    public void addAfterEmptyingSetTest()
    {
        addNoDupsElements();

        //remove all elements
        for (int i = 0; i < noDupsArray.length; i++)
        {
            set.remove(noDupsArray[i]);
        }

        //adding should still be successful
        set.add(2);
        assertEquals(1, set.size(), "The size of your set should be 1 after calling add() on an empty set");
    }

    /*
     * Adds a group of elements to the set, without any duplicates being added.
     */
    private void addNoDupsElements()
    {
        for (int i = 0; i < noDupsArray.length; i++)
        {
            set.add(noDupsArray[i]);
        }
        assertEquals(noDupsArray.length, set.size(),
                "The size of your set should be " + noDupsArray.length + "after calling add()");
    }
}
